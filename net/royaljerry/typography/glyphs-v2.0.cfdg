/**
 * ###########################
 * #                         #
 * # ContextFree Programming #
 * #                         #
 * #    © Adam Pócs 2013     #
 * #                         #
 * #  royaljerry@gmail.com   #
 * #                         #
 * ###########################
*/

/**
 * #############
 * # IMPORTANT #
 * #############
 * 
 * Shape "pixel" must be implemented in the parent script, e.g.:
 * 
 * shape pixel {SQUARE []}
*/

/**
 * ########
 * # Type #
 * ########
*/

/**
 * Description:    Type a glyph
 *
 * ARGUMENT        TYPE                DESCRIPTION
 *
 * cPos            Number              Position of the letter in the word (starting with 0)
 *
 * cLetter         Vector              Name of the glyph
 *
 * pX              Number              X positon of the glyph
 *
 * pY              Number              Y positon of the glyph (expanding to the bottom, so that y = 2 > y = 1)
 *
 * cKern           Number              Kerning (horizontal space between two letters)
 *
 * cLine           Number              Line height (vertical space between two letters)
 *
 * pixW            Number              Width of the glyph's pixels
 *
 * pixH            Number              Height of the glyph's pixels
 *
 * dX              Number              Horizontal random perturbation
 *
 * dY              Number              Vertical random perturbation
*/
shape type(vector5 cLetter, cKern, cLine, pX, pY, pixW, pixH, dX, dY)
{
	loop i = GLYPH_H []
	{
		loop j = GLYPH_W []
		{
			rX = rand(-dX, dX)
			rY = rand(-dY, dY)
			c = cLetter[i]
			cU = floor(c / (10 ^ (GLYPH_W - j))) * (10 ^ (GLYPH_W - j))
			cL = c - cU
			cN = floor(cL / (10 ^ (GLYPH_W - j - 1)))
			adj =
			[
				x (((cKern + GLYPH_W) * pX) + (j + (pixW / 2))  + rX)
				y (-((cLine + GLYPH_H) * pY) - (i + (pixH / 2)) + rY)
				s pixW pixH
			]
			/**
			 * Don't laugh...
			 * The following lines are here due to a bug in CFDG:
			 * cN cannot be passed as a 'number' argument. :)
			*/
			switch (cN)
			{
				case 0: pixel (0, pX, pY, i, j) [trans adj]
				case 1: pixel (1, pX, pY, i, j) [trans adj]
				case 2: pixel (2, pX, pY, i, j) [trans adj]
				case 3: pixel (3, pX, pY, i, j) [trans adj]
				case 4: pixel (4, pX, pY, i, j) [trans adj]
				case 5: pixel (5, pX, pY, i, j) [trans adj]
				case 6: pixel (6, pX, pY, i, j) [trans adj]
				case 7: pixel (7, pX, pY, i, j) [trans adj]
				case 8: pixel (8, pX, pY, i, j) [trans adj]
				case 9: pixel (9, pX, pY, i, j) [trans adj]
			}
		}
	}
}

shape t(vector5 cLetter, cKern, cLine) {type (cLetter, cKern, cLine, 0, 0, 1, 1, 0, 0) []}
shape tP(vector5 cLetter, cKern, cLine, pX, pY) {type (cLetter, cKern, cLine, pX, pY, 1, 1, 0, 0) []}
shape tS(vector5 cLetter, cKern, cLine, pixW, pixH) {type (cLetter, cKern, cLine, 0, 0, pixW, pixH, 0, 0) []}
shape tPS(vector5 cLetter, cKern, cLine, pX, pY, pixW, pixH) {type (cLetter, cKern, cLine, pX, pY, pixW, pixH, 0, 0) []}

/**
 * Description:    Type a random glyph
 *
 * ARGUMENT        TYPE                DESCRIPTION
 *
 * cPos            Number              Position of the letter in the word (starting with 0)
 *
 * pX              Number              X positon of the glyph
 *
 * pY              Number              Y positon of the glyph (expanding to the bottom, so that y = 2 > y = 1)
 *
 * cKern           Number              Kerning (horizontal space between two letters)
 *
 * cLine           Number              Line height (vertical space between two letters)
 *
 * pixW            Number              Width of the glyph's pixels
 *
 * pixH            Number              Height of the glyph's pixels
 *
 * dX              Number              Horizontal random perturbation
 *
 * dY              Number              Vertical random perturbation
*/
shape typeRand(cKern, cLine, pX, pY, pixW, pixH, dX, dY)

rule {type(_a, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_b, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_c, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_e, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_f, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_g, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_h, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_i, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_j, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_k, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_l, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_m, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_n, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_o, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_p, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_q, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_r, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_s, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_t, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_u, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_v, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_w, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_x, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_y, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_z, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d0, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d1, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d2, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d3, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d4, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d5, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d6, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d7, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d8, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}
rule {type(_d9, cKern, cLine, pX, pY, pixW, pixH, dX, dY)[]}

shape tRand(cKern, cLine) {typeRand(cKern, cLine, 0, 0, 1, 1, 0, 0)[]}
shape tRandP(cKern, cLine, pX, pY) {typeRand(cKern, cLine, pX, pY, 1, 1, 0, 0)[]}
shape tRandS(cKern, cLine, pixW, pixH) {typeRand(cKern, cLine, 0, 0, pixW, pixH, 0, 0)[]}
shape tRandPS(cKern, cLine, pX, pY, pixW, pixH) {typeRand(cKern, cLine, pX, pY, pixW, pixH, 0, 0)[]}
